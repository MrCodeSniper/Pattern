软件设计原则
1。找出app中可能需要变化之处 并把他们独立出来 不要和不需要变化的代码混在一起
2。针对接口编程 而不是对实现
3。多用组合 少用继承
4. 为了交互对象之间的松耦合设计而努力
5.类应该对扩展开放对修改关闭
6.最少知识原则 只和你的密友谈话


1。 策略模式:定义了算法集同属于解决某个特定问题 分别封装起来 并使程序在运行时 能动态改变运行哪个算法
2。 观察者模式: 分为观察者和被观察者 观察者与被观察者建立 监听关系 当被观察者发生变化时 通知观察者 观察者根据响应执行自己的
算法
3. 装饰者模式：动态将责任附加到对象上 适用于扩展功能
4  单例模式：确保一个类只有一个实例 并提供全局访问点
5。命令模式：请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令
将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化
6。 适配器模式 包装某些对象 让他们的接口看起来不像自己而是像别的东西
适配器将220V的中式电源接口转化为适配美式的
适配目标 适配器  被适配者     适配器实现适配目标接口  然后在这些实现方法中 使用被适配者的方法来配置 成配置目标的实现
7. 外观模式 提供了一个统一的接口，用来访问子系统中的一群接口 定义了一个高层接口
8。组合模式 又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象
这种模式创建了一个包含自己对象组的类 常常用一致的行为处理这些集合和根对象
9。迭代器模式  这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示
像链表一样的递归
10。 代理模式 为另一个对象 提供一个替身以访问这个对象
11。 复合模式 复合结合两个以上模式 组成一个解决方案 解决一再发生的一般性问题
携手合作 而不是 用到而已
12。 模版方法 定义了一系列行为为一个final的结合行为
父类决定模版方法的结合 子类决定方法执行的次序 步骤
13。责任链模式
让一个以上的对象处理 某个请求 就像okhttp的拦截器 请求和返回都经过拦截器列表的层层过滤




如果我们处理某个情景中 面对想要达到的目标 被多个问题困扰
然而我们能通过合理的设计 客服约束 达到目标 这个设计就是模式

设计模式是为了解决一个重复出现的问题  并不针对特殊情景


设计模式可以分为
结构
行为
创建





应用：
##比喻
1.在鸭群里 混进一个 鹅 并让鹅执行与鸭一样的行为(叫) 适配器模式
2.如何在鸭群中 计算鸭总共叫了几次 装饰器模式  通过把鸭子对象 放入装饰器对象中
装饰器对象 与鸭子对象都实现一样的接口 但 装饰器对象持有鸭子对象的引用，这个引用是由构造器传来的
用静态变量保存叫的次数  在装饰者的叫行为中 调用引用鸭子的叫方法 并叫次数+1
并把所有鸭子对象传入装饰器中
3。每个对象都要新建 并传入装饰器中 如果有100个新对象 那就太麻烦了
我们需要工厂来生产这些新的对象，这里我们要生产2个工厂
1）生产鸭子对象的工厂
2）生产传入不同鸭子对象装饰器的工厂
4。我们需要一种模式能管理 非常多的鸭子对象
这里可以用组合模式 写个对象 内部维护一个鸭子列表
也用到了迭代器模式 迭代鸭子发出叫声
5。我们还想观察个别鸭子的行为 使用观察者模式订阅鸭子 当鸭子发生叫声 我们能立即收到
如果我们观察的是一个组合 其内部有列表 就等于我们观察组合内所有东西









1。先设计UML图
2。写接口